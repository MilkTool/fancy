%% name = Fancy::KPEG

%% ast-location = ::Fancy::AST
%% integer_literal = ast IntegerLiteral(line, n, base)
%% expression_list = ast ExpressionList(line, car, cdr)
%% expression = ast Expression(line, exp)
%% statement = ast Statement(line, stm)
%% identifier = ast Identifier(line, id)
%% assignment = ast Assignment(line, id, obj)
%% symbol_literal = ast SymbolLiteral(line, text)
%% float_literal = ast FloatLiteral(line, n)
%% string_literal = ast StringLiteral(line, text)
%% array_literal = ast ArrayLiteral(line, elements)
%% hash_literal = ast HashLiteral(line, kvl)
%% block_literal = ast BlockLiteral(line, args, body)
%% returns = ast Returns(line, obj)
%% returns_local = ast ReturnsLocal(line, obj)
%% code = ast Code(line, code)

CASE         = "case"
CATCH        = "catch"
CLASS        = "class"
DEF          = "def"
FINALLY      = "finally"
MATCH        = "match"
PRIVATE      = "private"
PROTECTED    = "protected"
RETRY        = "retry"
RETURN_LOCAL = "return_local"
RETURN       = "return"
SELF         = "self"
SUPER        = "super"
TRY          = "try"

ARROW           = "=>"
COLON           = ":"
COMMA           = ","
DOLLAR          = "$"
DOT             = "."
EQUALS          = "="
LBRACKET        = "["
LCURLY          = "{"
LHASH           = "<["
LPAREN          = "("
RBRACKET        = "]"
RCURLY          = "}"
RHASH           = "]>"
RPAREN          = ")"
SEMI            = ";"
STAB            = "|"
THIN_ARROW      = "->"
ESCAPED_NEWLINE = "\\\n"
NL              = "\n"

BINDIGIT      = /[01]/
CAPITAL       = /[A-Z]/
DIGIT         = /[0-9]/
HEXDIGIT      = /[0-9a-fA-F]/
LETTER        = /[A-Za-z]/
LOWER         = /[a-z]/
OCTDIGIT      = /[0-7]/
SPECIAL       = /[-+?!=*\/^><%&~]/
DELIMITER     = /[ \n\r\t()]/
COMMENT       = "#" /[^\n]/*
REGEX_LITERAL = "/" .* "/"

ESCAPE = '"'  { "\"" }
       | "\\" { "\\" }
       | <.>  { text }

SPECIAL_UNDER    = SPECIAL | "_"
OPERATOR         = SPECIAL+ | "||" SPECIAL_UNDER*
INTEGER_LITERAL  = /[-+]?/ /[1-9]/ (DIGIT | "_" DIGIT)*
DOUBLE_LITERAL   = INTEGER_LITERAL "." ("_" DIGIT | DIGIT)*
HEX_LITERAL      = "0" ("x" | "X") <HEXDIGIT+> { text }
BIN_LITERAL      = "0" ("b" | "B") <BINDIGIT+> { text }
OCT_LITERAL      = "0" ("o" | "O") <OCTDIGIT+> { text }

STRING_CORE = (("\\" .) | /[^\\"]/)*
STRING_LITERAL = "\"" <STRING_CORE> "\"" { text }
MULTILINE_STRING = "\"\"\"" <STRING_CORE> "\"\"\"" { text }

IDENTIFIER       = "@"? "@"? (LOWER | /[_&*]/) (LETTER | DIGIT | SPECIAL_UNDER)*
CONSTANT         = CAPITAL (LETTER | DIGIT | SPECIAL_UNDER)*
NESTED_CONSTANT  = (CONSTANT "::")+ CONSTANT
SYMBOL_LITERAL   = "'" <(IDENTIFIER | OPERATOR | ":" | "[]")+> { text }
RUBY_SEND_OPEN   = IDENTIFIER LPAREN
RUBY_OPER_OPEN   = OPERATOR LPAREN

root = /\A\s*\Z/
     | expression_list:el !. { el }

expression_list = code:x (delim code)*:xs delim? ~expression_list(current_line, x, xs)

delim = (NL | SEMI)+

nls = NL+

space = " "
      | nls

code = statement
     | exp

statement = assignment
          | return_local_statement
          | return_statement

exp = method_def
    | class_def
    | try_catch_block
    | match_expr
    | message_send
    | operator_send
    | ruby_send
    | ruby_oper_send
    | literal_value
    | any_identifier
    | SUPER { $$ = rb_funcall(self, rb_intern("super_exp"), 1, INT2NUM(yylineno)); }
    | RETRY { $$ = rb_funcall(self, rb_intern("retry_exp"), 1, INT2NUM(yylineno)); }
    | LPAREN space exp space RPAREN { $$ = $3; }
    | exp DOT space { $$ = $1; }

assignment = any_identifier:id space EQUALS space exp:e ~assignment(current_line, id, e)
           | multiple_assignment

multiple_assignment = identifier_list EQUALS exp_comma_list {
                  $$ = rb_funcall(self, rb_intern("multiple_assignment"), 3, INT2NUM(yylineno), $1, $3);
                }

operator = <OPERATOR> ~identifier(current_line, text)

constant = <CONSTANT> ~constant(current_line, text)

identifier = <IDENTIFIER> ~identifier(current_line, text)
           | <MATCH> ~identifier(current_line, text)
           | <CLASS> ~identifier(current_line, text)

any_identifier = const_identifier
               | identifier

identifier_list = any_identifier
                | identifier_list:a COMMA any_identifier:b { identifier_list(0, a, b) }

return_statement = RETURN space? exp:a ~returns(current_line, a)
                 | RETURN ~returns(current_line, nil)

return_local_statement = RETURN_LOCAL space? exp:a ~returns_local(current_line, a)
                       | RETURN_LOCAL ~returns_local(current_line, nil)

class_def =      class_no_super
                | class_super

const_identifier = constant {
                  $$ = rb_funcall(self, rb_intern("const_identifier"), 2, INT2NUM(yylineno), $1);
                }
                | const_identifier constant {
                  $$ = rb_funcall(self, rb_intern("const_identifier"), 3, INT2NUM(yylineno), $2, $1);
                }

def = DEF PRIVATE { $$ = rb_intern("private"); }
    | DEF PROTECTED { $$ = rb_intern("protected"); }
    | DEF { $$ = rb_intern("public"); }

class_no_super = CLASS const_identifier expression_block {
                  $$ = rb_funcall(self, rb_intern("class_def"), 4, INT2NUM(yylineno), $2, Qnil, $3);
                }

class_super =    CLASS const_identifier COLON const_identifier expression_block {
                  $$ = rb_funcall(self, rb_intern("class_def"), 4, INT2NUM(yylineno), $2, $4, $5);
                }

method_def =     method_w_args
                | method_no_args
                | class_method_w_args
                | class_method_no_args
                | operator_def
                | class_operator_def

method_arg =     identifier COLON identifier {
                  $$ = rb_funcall(self, rb_intern("method_arg"), 3, INT2NUM(yylineno), $1, $3);
                }

method_args =    method_arg {
                  $$ = rb_funcall(self, rb_intern("expr_ary"), 2, INT2NUM(yylineno), $1);
                }
                | method_args method_arg {
                  $$ = rb_funcall(self, rb_intern("expr_ary"), 3, INT2NUM(yylineno), $2, $1);
                }
                | method_args method_args_default {
                  $$ = rb_funcall(self, rb_intern("expr_ary"), 3, INT2NUM(yylineno), $2, $1);
                }

method_arg_default = identifier COLON identifier LPAREN space exp space RPAREN {
                  $$ = rb_funcall(self, rb_intern("method_arg"), 4, INT2NUM(yylineno), $1, $3, $6);
                }

method_args_default = method_arg_default {
                  $$ = rb_funcall(self, rb_intern("expr_ary"), 2, INT2NUM(yylineno), $1);
                }
                | method_args_default space method_arg_default {
                  $$ = rb_funcall(self, rb_intern("expr_ary"), 3, INT2NUM(yylineno), $3, $1);
                }

method_w_args =  def method_args expression_block {
                  $$ = rb_funcall(self, rb_intern("method_def_expand"), 4, INT2NUM(yylineno), $2, $3, $1);
                }


method_no_args = def identifier expression_block {
                  $$ = rb_funcall(self, rb_intern("method_def_no_args"), 4, INT2NUM(yylineno), $2, $3, $1);
                }


class_method_w_args = def any_identifier method_args expression_block {
                  $$ = rb_funcall(self, rb_intern("sin_method_def_expand"), 5, INT2NUM(yylineno), $2, $3, $4, $1);
                }

class_method_no_args = def any_identifier identifier expression_block {
                  $$ = rb_funcall(self, rb_intern("sin_method_def_no_args"), 5, INT2NUM(yylineno), $2, $3, $4, $1);
                }

operator_def =   def operator identifier expression_block {
                  $$ = rb_funcall(self, rb_intern("operator_def"), 5, INT2NUM(yylineno), $2, $3, $4, $1);
                }
                | def LBRACKET RBRACKET identifier expression_block {
                  $$ = rb_funcall(self, rb_intern("operator_def"), 5,
                                  INT2NUM(yylineno), fy_terminal_node_from(self, "identifier", "[]"), $4, $5, $1);
                }

class_operator_def = def any_identifier operator identifier expression_block {
                  $$ = rb_funcall(self, rb_intern("sin_operator_def"), 6, INT2NUM(yylineno), $2, $3, $4, $5, $1);
                }
                | def any_identifier LBRACKET RBRACKET identifier expression_block {
                  $$ = rb_funcall(self, rb_intern("sin_operator_def"), 6,
                                  INT2NUM(yylineno), $2, fy_terminal_node_from(self, "identifier", "[]"), $5, $6, $1);
                }

message_send =   exp identifier {
                  $$ = rb_funcall(self, rb_intern("msg_send_basic"), 3, INT2NUM(yylineno), $1, $2);
                }
                | exp send_args {
                  $$ = rb_funcall(self, rb_intern("msg_send_args"), 3, INT2NUM(yylineno), $1, $2);
                }
                | send_args {
                  $$ = rb_funcall(self, rb_intern("msg_send_args"), 3, INT2NUM(yylineno), Qnil, $1);
                }

ruby_send_open = RUBY_SEND_OPEN {
                  # remove the trailing left paren and create an identifier.
                  $$ = fy_terminal_node(self, "ruby_send_open");
                }
ruby_oper_open = RUBY_OPER_OPEN {
                  # remove the trailing left paren and create an identifier.
                  $$ = fy_terminal_node(self, "ruby_send_open");
                }

ruby_send =      exp ruby_send_open ruby_args {
                  $$ = rb_funcall(self, rb_intern("msg_send_ruby"), 4, INT2NUM(yylineno), $1, $2, $3);
                }
                | ruby_send_open ruby_args {
                  $$ = rb_funcall(self, rb_intern("msg_send_ruby"), 4, INT2NUM(yylineno), Qnil, $1, $2);
                }

ruby_args =      RPAREN block  {
                  $$ = rb_funcall(self, rb_intern("ruby_args"), 3, INT2NUM(yylineno), Qnil, $2);
                }
                | exp_comma_list RPAREN block {
                  $$ = rb_funcall(self, rb_intern("ruby_args"), 3, INT2NUM(yylineno), $1, $3);
                }
                | RPAREN {
                  $$ = rb_funcall(self, rb_intern("ruby_args"), 1, INT2NUM(yylineno));
                }
                | exp_comma_list RPAREN {
                  $$ = rb_funcall(self, rb_intern("ruby_args"), 2, INT2NUM(yylineno), $1);
                }

operator_send = exp:a operator:b arg_exp:c ~operator_send_basic(current_line, a, b, c)
              | exp:a operator:b DOT space arg_exp:c ~operator_send_basic(current_line, a, b, c)
              | exp:a LBRACKET exp:b RBRACKET ~operator_send_basic(current_line, a, "[]", b)

ruby_oper_send = exp ruby_oper_open ruby_args {
                  $$ = rb_funcall(self, rb_intern("msg_send_ruby"), 4, INT2NUM(yylineno), $1, $2, $3);
                }


send_args =      identifier COLON arg_exp {
                  $$ = rb_funcall(self, rb_intern("send_args"), 3, INT2NUM(yylineno), $1, $3);
                }
                | identifier COLON space arg_exp {
                  $$ = rb_funcall(self, rb_intern("send_args"), 3, INT2NUM(yylineno), $1, $4);
                }
                | send_args identifier COLON arg_exp {
                  $$ = rb_funcall(self, rb_intern("send_args"), 4, INT2NUM(yylineno), $2, $4, $1);
                }
                | send_args identifier COLON space arg_exp {
                  $$ = rb_funcall(self, rb_intern("send_args"), 4, INT2NUM(yylineno), $2, $5, $1);
                }

arg_exp =        any_identifier {
                  $$ = $1;
                }
                | LPAREN exp RPAREN {
                  $$ = $2;
                }
                | literal_value {
                  $$ = $1;
                }
                | DOLLAR exp {
                  $$ = $2;
                }

try_catch_block = TRY expression_block catch_blocks finally_block {
                  $$ = rb_funcall(self, rb_intern("try_catch_finally"), 4, INT2NUM(yylineno), $2, $3, $4);
                }
                | TRY expression_block required_catch_blocks {
                  $$ = rb_funcall(self, rb_intern("try_catch_finally"), 3, INT2NUM(yylineno), $2, $3);
                }

catch_block =    CATCH expression_block  {
                  $$ = rb_funcall(self, rb_intern("catch_handler"), 2, INT2NUM(yylineno), $2);
                }
                | CATCH exp expression_block {
                  $$ = rb_funcall(self, rb_intern("catch_handler"), 3, INT2NUM(yylineno), $3, $2);
                }
                | CATCH exp ARROW identifier expression_block {
                  $$ = rb_funcall(self, rb_intern("catch_handler"), 4, INT2NUM(yylineno), $5, $2, $4);
                }

required_catch_blocks = catch_block {
                  $$ = rb_funcall(self, rb_intern("catch_handlers"), 2, INT2NUM(yylineno), $1);
                }
                | required_catch_blocks catch_block {
                  $$ = rb_funcall(self, rb_intern("catch_handlers"), 3, INT2NUM(yylineno), $2, $1);
                }

catch_blocks =   catch_block {
                  $$ = rb_funcall(self, rb_intern("catch_handlers"), 2, INT2NUM(yylineno), $1);
                }
                | catch_blocks catch_block {
                  $$ = rb_funcall(self, rb_intern("catch_handlers"), 3, INT2NUM(yylineno), $2, $1);
                }
                | " " {
                  $$ = rb_funcall(self, rb_intern("catch_handlers"), 1, INT2NUM(yylineno));
                }

finally_block =  FINALLY expression_block {
                  $$ = $2;
                }

integer = <INTEGER_LITERAL> ~integer_literal(current_line, text, 10)
hex = <HEX_LITERAL> ~integer_literal(current_line, text, 16)
oct = <OCT_LITERAL> ~integer_literal(current_line, text, 8)
bin = <BIN_LITERAL> ~integer_literal(current_line, text, 2)

double = <DOUBLE_LITERAL> ~float_literal(current_line, text)

string = STRING_LITERAL:s ~string_literal(current_line, s)
               | MULTILINE_STRING:s ~multiline_string(current_line, s)

symbol = SYMBOL_LITERAL:s ~symbol_literal(current_line, s)

regex = <REGEX_LITERAL> { Regexp.new(text) }

literal_value = double
              | hex
              | oct
              | bin
              | integer
              | string
              | symbol
              | hash
              | array
              | regex
              | block
              | tuple
              | range

array = filled_array | empty_array

filled_array = LBRACKET space? exp_comma_list:e space? RBRACKET ~array_literal(current_line, e)

exp_comma_list = exp:a space? COMMA space? exp_comma_list:b { [a, *b] }
               | exp:a space? COMMA space? exp:b { [a, b] }
               | exp:a { [a] }

empty_array = LBRACKET space? RBRACKET ~array_literal(current_line, [])

hash = LHASH space? key_value_list:kvl space? RHASH ~hash_literal(current_line, kvl)
     | LHASH space? RHASH ~hash_literal(current_line, {})

key_value_list = exp:k space? ARROW space? exp:v space? COMMA space? key_value_list:kvl { kvl.merge!(k => v) }
               | exp:k space? ARROW space? exp:v { {k => v} }


block = STAB block_args:a STAB space expression_block:b ~block_literal(current_line, a, b)
      | expression_block:a ~block_literal(current_line, nil, a)

expression_block = LCURLY space? expression_list:el space? RCURLY { el }
                 | LCURLY space? RCURLY

tuple =  LPAREN exp_comma_list RPAREN {
                  $$ = rb_funcall(self, rb_intern("tuple_literal"), 2, INT2NUM(yylineno), $2);
                }

range =  LPAREN exp DOT DOT exp RPAREN {
                  $$ = rb_funcall(self, rb_intern("range_literal"), 3, INT2NUM(yylineno), $2, $5);
                }

block_args = block_args_with_comma
           | block_args_without_comma

block_args_without_comma = identifier {
                  $$ = rb_funcall(self, rb_intern("block_args"), 2, INT2NUM(yylineno), $1);
                }
                | block_args_without_comma identifier {
                  $$ = rb_funcall(self, rb_intern("block_args"), 3, INT2NUM(yylineno), $2, $1);
                }

block_args_with_comma = identifier:a space? COMMA space? block_args_with_comma:b { [a, b] }
                      | identifier

match_expr =     MATCH exp LCURLY space match_body space RCURLY {
                  $$ = rb_funcall(self, rb_intern("match_expr"), 3, INT2NUM(yylineno), $2, $5);
                }

match_body =     match_clause {
                  $$ = rb_funcall(self, rb_intern("match_body"), 2, INT2NUM(yylineno), $1);
                }
                | match_body match_clause {
                  $$ = rb_funcall(self, rb_intern("match_body"), 3, INT2NUM(yylineno), $2, $1);
                }

match_clause =   CASE exp THIN_ARROW expression_list {
                  $$ = rb_funcall(self, rb_intern("match_clause"), 3, INT2NUM(yylineno), $2, $4);
                }
                | CASE exp THIN_ARROW STAB block_args STAB expression_list {
                  $$ = rb_funcall(self, rb_intern("match_clause"), 4, INT2NUM(yylineno), $2, $7, $5);
                }
