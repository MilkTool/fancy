!RBIX
0
x
M
1
n
n
x
10
__script__
i
29
99
7
0
1
65
49
1
3
13
99
12
7
2
12
7
3
12
65
12
49
4
4
15
49
2
0
15
2
11
I
6
I
0
I
0
I
0
n
p
5
x
6
Symbol
x
10
open_class
x
14
__class_init__
M
1
n
n
x
6
Symbol
i
25
5
66
7
0
64
15
5
49
1
0
15
99
7
2
7
3
65
67
49
4
0
49
5
4
11
I
5
I
0
I
0
I
0
n
p
6
s
189
""
  Symbols are unique identifiers and only created once.

  If there are several occurrances of the same Symbol literal within
  Fancy code, they all refer to the same Symbol object.
  ""
x
6
public
x
5
call:
M
1
n
n
x
5
call:
i
20
7
0
64
15
20
0
45
1
2
49
3
1
56
4
56
5
49
6
2
11
I
4
I
1
I
1
I
1
n
p
7
s
149
""
    This allows Symbols to be used like Blocks
    (e.g. in all methods of Enumerable).
    Example: [1, 2, 3] map: 'squared # => [1, 4, 9]
    ""
x
5
Array
n
x
6
is_a?:
M
1
p
2
x
9
for_block
t
n
x
5
call:
i
17
21
1
0
49
0
0
5
21
1
0
49
1
0
49
2
2
11
I
4
I
0
I
0
I
0
n
p
3
x
6
:first
x
5
:rest
x
12
send:params:
p
7
I
0
I
12
I
0
I
11
I
d
I
12
I
11
x
32
/more/vic/hk/fancy/lib/symbol.fy
p
0
M
1
p
2
x
9
for_block
t
n
x
5
call:
i
8
21
1
0
5
49
0
1
11
I
3
I
0
I
0
I
0
n
p
1
x
5
send:
p
7
I
0
I
14
I
0
I
13
I
4
I
14
I
8
x
32
/more/vic/hk/fancy/lib/symbol.fy
p
0
x
13
if_true:else:
p
15
I
0
I
15
I
0
I
f
I
0
I
e
I
4
I
10
I
c
I
12
I
e
I
14
I
10
I
15
I
14
x
32
/more/vic/hk/fancy/lib/symbol.fy
p
1
x
3
arg
x
17
method_visibility
x
15
add_defn_method
p
5
I
2
I
7
I
6
I
15
I
19
x
32
/more/vic/hk/fancy/lib/symbol.fy
p
0
x
13
attach_method
p
5
I
0
I
18
I
0
I
17
I
1d
x
32
/more/vic/hk/fancy/lib/symbol.fy
p
0
