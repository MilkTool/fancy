# *** This file is generated by InstructionParser ***

def class Rubinius {
  def class GeneratorMethods {
    def noop {
        @stream << 0;
        @ip = @ip + 1;
        @instruction = 0
    }

    def push_nil {
      @stream << 1;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 1
    }

    def push_true {
      @stream << 2;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 2
    }

    def push_false {
      @stream << 3;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 3
    }

    def push_int: arg1 {
      (arg1 > 2) and: (arg1 < 256) . if_true: {
        @stream << 4 << arg1;
        @current_block add_stack: 1;
        @ip = @ip + 2;
        @instruction = 4
      } else: {
        # TODO: translate this:
        # case arg1
        # when -1
        #   meta_push_neg_1
        # when 0
        #   meta_push_0
        # when 1
        #   meta_push_1
        # when 2
        #   meta_push_2
        # else
        #   push_literal arg1
        # end
      }
    }

    def push_self {
      @stream << 5;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 5
    }

    def set_literal: arg1 {
      @stream << 6 << arg1;
      @ip = @ip + 2;
      @instruction = 6
    }

    def emit_push_literal: arg1 {
      @stream << 7 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: 1;
      @instruction = 7
    }

    def goto: arg1 {
      location = @ip + 1;
      @stream << 8 << arg1;
      @ip = @ip + 2;
      arg1 used_at: location;
      @current_block add_edge: $ arg1 basic_block;
      @current_block close;
      @current_block = self new_basic_block;
      @instruction = 8
    }

    def gif: arg1 {
      location = @ip + 1;
      @stream << 9 << arg1;
      @ip = @ip + 2;
      arg1 used_at: location;
      @current_block add_stack: -1;
      @current_block add_edge: $ arg1 basic_block;
      @current_block close;
      block = self new_basic_block;
      @current_block add_edge: block;
      @current_block = block;
      @instruction = 9
    }

    def git: arg1 {
      location = @ip + 1;
      @stream << 10 << arg1;
      @ip = @ip + 2;
      arg1 used_at: location;
      @current_block add_stack: -1;
      @current_block add_edge: $ arg1 basic_block;
      @current_block close;
      block = self new_basic_block;
      @current_block add_edge: block;
      @current_block = block;
      @instruction = 10
    }

    def ret {
      @stream << 11;
      @ip = @ip + 1;
      @current_block close;
      @current_block = self new_basic_block;
      @instruction = 11
    }

    def swap {
      @stream << 12;
      @ip = @ip + 1;
      @instruction = 12
    }

    def dup {
      @stream << 13;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 13
    }

    def dup_many: arg1 {
      @stream << 14 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: $ arg1 negate + (arg1 * 2);
      @instruction = 14
    }

    def pop {
      @stream << 15;
      @ip = @ip + 1;
      @current_block add_stack: -1;
      @instruction = 15
    }

    def pop_many: arg1 {
      @stream << 16 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: $ arg1 negate;
      @instruction = 16
    }

    def rotate: arg1 {
      @stream << 17 << arg1;
      @ip = @ip + 2;
      @instruction = 17
    }

    def move_down: arg1 {
      @stream << 18 << arg1;
      @ip = @ip + 2;
      @instruction = 18
    }

    def set_local: arg1 {
      @stream << 19 << arg1;
      @ip = @ip + 2;
      @instruction = 19
    }

    def push_local: arg1 {
      @stream << 20 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: 1;
      @instruction = 20
    }

    def push_local_depth: arg1 arg2: arg2 {
      @stream << 21 << arg1 << arg2;
      @ip = @ip + 3;
      @current_block add_stack: 1;
      @instruction = 21
    }

    def set_local_depth: arg1 arg2: arg2 {
      @stream << 22 << arg1 << arg2;
      @ip = @ip + 3;
      @instruction = 22
    }

    def passed_arg: arg1 {
      @stream << 23 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: 1;
      @instruction = 23
    }

    def push_current_exception {
      @stream << 24;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 24
    }

    def clear_exception {
      @stream << 25;
      @ip = @ip + 1;
      @instruction = 25
    }

    def push_exception_state {
      @stream << 26;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 26
    }

    def restore_exception_state {
      @stream << 27;
      @ip = @ip + 1;
      @current_block add_stack: -1;
      @instruction = 27
    }

    def raise_exc {
      @stream << 28;
      @ip = @ip + 1;
      @current_block close;
      @current_block = self new_basic_block;
      @instruction = 28
    }

    def setup_unwind: arg1 arg2: arg2 {
      location = @ip + 1;
      @stream << 29 << arg1 << arg2;
      @ip = @ip + 3;
      arg1 used_at: location;
      @current_block add_edge: $ arg1 basic_block;
      @current_block close;
      block = self new_basic_block;
      @current_block add_edge: block;
      @current_block = block;
      @instruction = 29
    }

    def pop_unwind {
      @stream << 30;
      @ip = @ip + 1;
      @instruction = 30
    }

    def raise_return {
      @stream << 31;
      @ip = @ip + 1;
      @current_block close;
      @current_block = self new_basic_block;
      @instruction = 31
    }

    def ensure_return {
      @stream << 32;
      @ip = @ip + 1;
      @current_block close;
      @current_block = self new_basic_block;
      @instruction = 32
    }

    def raise_break {
      @stream << 33;
      @ip = @ip + 1;
      @current_block close;
      @current_block = self new_basic_block;
      @instruction = 33
    }

    def reraise {
      @stream << 34;
      @ip = @ip + 1;
      @current_block close;
      @current_block = self new_basic_block;
      @instruction = 34
    }

    def make_array: arg1 {
      @stream << 35 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: $ 1 - arg1;
      @instruction = 35
    }

    def cast_array {
      (@instruction == 36) or: (@instruction == 35) if_false: {
        @stream << 36;
        @ip = @ip + 1
      };
      @instruction = 36
    }

    def shift_array {
      @stream << 37;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 37
    }

    def set_ivar: arg1 {
      arg1 = self find_literal: arg1;
      @stream << 38 << arg1;
      @ip = @ip + 2;
      @instruction = 38
    }

    def push_ivar: arg1 {
      arg1 = self find_literal: arg1;
      @stream << 39 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: 1;
      @instruction = 39
    }

    def set_const: arg1 {
      @stream << 41 << arg1;
      @ip = @ip + 2;
      @instruction = 41
    }

    def set_const_at: arg1 {
      @stream << 42 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: -2;
      @instruction = 42
    }

    def find_const: arg1 {
      arg1 = self find_literal: arg1;
      @stream << 43 << arg1;
      @ip = @ip + 2;
      @instruction = 43
    }

    def push_cpath_top {
      @stream << 44;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 44
    }

    def push_const_fast: arg1 arg2: arg2 {
      @stream << 45 << arg1 << arg2;
      @ip = @ip + 3;
      @current_block add_stack: 1;
      @instruction = 45
    }

    def set_call_flags: arg1 {
      @stream << 46 << arg1;
      @ip = @ip + 2;
      @instruction = 46
    }

    def allow_private {
      @stream << 47;
      @ip = @ip + 1;
      @instruction = 47
    }

    def send_method: arg1 {
      @stream << 48 << arg1;
      @ip = @ip + 2;
      @instruction = 48
    }

    def send_stack: arg1 arg2: arg2 {
      @stream << 49 << arg1 << arg2;
      @ip = @ip + 3;
      @current_block add_stack: $ arg2 negate;
      @instruction = 49
    }

    def send_stack_with_block: arg1 arg2: arg2 {
      @stream << 50 << arg1 << arg2;
      @ip = @ip + 3;
      @current_block add_stack: $ -1 - arg2;
      @instruction = 50
    }

    def send_stack_with_splat: arg1 arg2: arg2 {
      @stream << 51 << arg1 << arg2;
      @ip = @ip + 3;
      @current_block add_stack: $ -2 - arg2;
      @instruction = 51
    }

    def send_super_stack_with_block: arg1 args: arg2 {
      @stream << 52 << arg1 << arg2;
      @ip = @ip + 3;
      @current_block add_stack: $ arg2 negate;
      @instruction = 52
    }

    def send_super_stack_with_splat: arg1 arg2: arg2 {
      @stream << 53 << arg1 << arg2;
      @ip = @ip + 3;
      @current_block add_stack: $ -1 - arg2;
      @instruction = 53
    }

    def push_block {
      @stream << 54;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 54
    }

    def passed_blockarg: arg1 {
      @stream << 55 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: 1;
      @instruction = 55
    }

    def create_block: arg1 {
      arg1 = self add_literal: arg1;
      @generators << arg1;
      @stream << 56 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: 1;
      @instruction = 56
    }

    def cast_for_single_block_arg {
      @stream << 57;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 57
    }

    def cast_for_multi_block_arg {
      @stream << 58;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 58
    }

    def cast_for_splat_block_arg {
      @stream << 59;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 59
    }

    def yield_stack: arg1 {
      @stream << 60 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: $  1 - arg1;
      @instruction = 60
    }

    def yield_splat: arg1 {
      @stream << 61 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: $ arg1 negate;
      @instruction = 61
    }

    def string_append {
      @stream << 62;
      @ip = @ip + 1;
      @current_block add_stack: -1;
      @instruction = 62
    }

    def string_build: arg1 {
      @stream << 63 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: $  1 - arg1;
      @instruction = 63
    }

    def string_dup {
      @stream << 64;
      @ip = @ip + 1;
      @instruction = 64
    }

    def push_scope {
      @stream << 65;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 65
    }

    def add_scope {
      @stream << 66;
      @ip = @ip + 1;
      @current_block add_stack: -1;
      @instruction = 66
    }

    def push_variables {
      @stream << 67;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 67
    }

    def check_interrupts {
      @stream << 68;
      @ip = @ip + 1;
      @instruction = 68
    }

    def yield_debugger {
      @stream << 69;
      @ip = @ip + 1;
      @instruction = 69
    }

    def is_nil {
      @stream << 70;
      @ip = @ip + 1;
      @instruction = 70
    }

    def check_serial: arg1 arg2: arg2 {
      arg1 = self find_literal: arg1;
      arg2 = arg2 to_i; # arg2 = Integer(arg2)
      @stream << 71 << arg1 << arg2;
      @ip = @ip + 3;
      @instruction = 71
    }

    def check_serial_private: arg1 arg2: arg2 {
      arg1 = self find_literal arg1;
      arg2 = arg2 to_i; # arg2 = Integer(arg2)
      @stream << 72 << arg1 << arg2;
      @ip = @ip + 3;
      @instruction = 72
    }

    def push_my_field: arg1 {
      @stream << 73 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: 1;
      @instruction = 73
    }

    def store_my_field: arg1 {
      @stream << 74 << arg1;
      @ip = @ip + 2;
      @instruction = 74
    }

    def kind_of {
      @stream << 75;
      @ip = @ip + 1;
      @current_block add_stack: -1;
      @instruction = 75
    }

    def instance_of {
      @stream << 76;
      @ip = @ip + 1;
      @current_block add_stack: -1;
      @instruction = 76
    }

    def meta_push_neg_1 {
      @stream << 77;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 77
    }

    def meta_push_0 {
      @stream << 78;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 78
    }

    def meta_push_1 {
      @stream << 79;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 79
    }

    def meta_push_2 {
      @stream << 80;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 80
    }

    def meta_send_op_plus: arg1 {
      @stream << 81 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: -1;
      @instruction = 81
    }

    def meta_send_op_minus: arg1 {
      @stream << 82 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: -1;
      @instruction = 82
    }

    def meta_send_op_equal: arg1 {
      @stream << 83 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: -1;
      @instruction = 83
    }

    def meta_send_op_lt: arg1 {
      @stream << 84 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: -1;
      @instruction = 84
    }

    def meta_send_op_gt: arg1 {
      @stream << 85 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: -1;
      @instruction = 85
    }

    def meta_send_op_tequal: arg1 {
      @stream << 86 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: -1;
      @instruction = 86
    }

    def meta_send_call: arg1 arg2: arg2 {
      @stream << 87 << arg1 << arg2;
      @ip = @ip + 3;
      @current_block add_stack: $ arg2 negate;
      @instruction = 87
    }

    def push_my_offset: arg1 {
      @stream << 88 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: 1;
      @instruction = 88
    }

    def zsuper: arg1 {
      arg1 = self find_literal: arg1;
      @stream << 89 << arg1;
      @ip = @ip + 2;
      @instruction = 89
    }

    def push_block_arg {
      @stream << 90;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 90
    }

    def push_undef {
      @stream << 91;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 91
    }

    def push_stack_local: arg1 {
      @stream << 92 << arg1;
      @ip = @ip + 2;
      @current_block add_stack: 1;
      @instruction = 92
    }

    def set_stack_local: arg1 {
      @stream << 93 << arg1;
      @ip = @ip + 2;
      @instruction = 93
    }

    def push_has_block {
      @stream << 94;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 94
    }

    def push_proc {
      @stream << 95;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 95
    }

    def check_frozen {
      @stream << 96;
      @ip = @ip + 1;
      @instruction = 96
    }

    def cast_multi_value {
      @stream << 97;
      @ip = @ip + 1;
      @instruction = 97
    }

    def invoke_primitive: arg1 arg2: arg2 {
      arg1 = self find_literal: arg1;
      arg2 = arg2 to_i; # arg2 = Integer(arg2)
      @stream << 98 << arg1 << arg2;
      @ip = @ip + 3;
      @current_block add_stack: $ 1 - arg2;
      @instruction = 98
    }

    def push_rubinius {
      @stream << 99;
      @ip = @ip + 1;
      @current_block add_stack: 1;
      @instruction = 99
    }

  }
}
